## rmvnorm function for proposals
rmvnorm<-function(n,mu,Sigma)
{ # samples from the multivariate normal distribution
E<-matrix(rnorm(n*length(mu)),n,length(mu))
t(  t(E%*%chol(Sigma)) +c(mu))
}
## MCMC
for(s in 1:S) {
#propose a new beta
beta.p<- t(rmvnorm(1, beta, var.prop))
lhr<- sum(dbern(y, exp(X%*%beta.p)/(1+exp(X%*%beta.p)) ,log=T)) -
sum(dbern(y, exp(X%*%beta)/(1+exp(X%*%beta)) ,log=T)) +
sum(dnorm(beta.p,pmn.beta,psd.beta,log=T)) -
sum(dnorm(beta,pmn.beta,psd.beta,log=T))
if( log(runif(1))< lhr ) { beta<-beta.p ; ac<-ac+1 }
BETA[s,]<-beta
}
# Plot the results:
print('Acceptance ratio:')
print(ac/S)
plot(BETA[,2],type="l",xlab="MCMC Iteration",ylab=expression(theta),main="Trace plot")
acf(BETA[,2])
print("Posterior means")
colMeans(BETA)
print("Effective sample size of both parameters")
ESS(BETA[,1])
ESS(BETA[,2])
n<-length(y) ; p<-dim(X)[2]
# priors and initialization
# can change these priors
pmn.beta<-c(-10,1)
psd.beta<-rep(10,p)
# can tweak the +-
var.prop<- var(logit(ifelse(y==1, y-0.05, y+0.05)))*solve( t(X)%*%X )
beta<-rep(0,p) # starting beta
S<-10000
BETA<-matrix(0,nrow=S,ncol=p)
ac<-0
# set.seed(1) # set seed
## rmvnorm function for proposals
rmvnorm<-function(n,mu,Sigma)
{ # samples from the multivariate normal distribution
E<-matrix(rnorm(n*length(mu)),n,length(mu))
t(  t(E%*%chol(Sigma)) +c(mu))
}
## MCMC
for(s in 1:S) {
#propose a new beta
beta.p<- t(rmvnorm(1, beta, var.prop))
lhr<- sum(dbern(y, exp(X%*%beta.p)/(1+exp(X%*%beta.p)) ,log=T)) -
sum(dbern(y, exp(X%*%beta)/(1+exp(X%*%beta)) ,log=T)) +
sum(dnorm(beta.p,pmn.beta,psd.beta,log=T)) -
sum(dnorm(beta,pmn.beta,psd.beta,log=T))
if( log(runif(1))< lhr ) { beta<-beta.p ; ac<-ac+1 }
BETA[s,]<-beta
}
# Plot the results:
print('Acceptance ratio:')
print(ac/S)
plot(BETA[,2],type="l",xlab="MCMC Iteration",ylab=expression(theta),main="Trace plot")
acf(BETA[,2])
print("Posterior means")
colMeans(BETA)
print("Effective sample size of both parameters")
ESS(BETA[,1])
ESS(BETA[,2])
hist(rnorm(5000, -10, 10))
hist(rnorm(5000, 0.8, 10))
hist(BETA[,1])
hist(BETA[,2])
n<-length(y) ; p<-dim(X)[2]
# priors and initialization
# can change these priors
pmn.beta<-c(-5,0.5)
psd.beta<-rep(10,p)
# can tweak the +-
var.prop<- var(logit(ifelse(y==1, y-0.05, y+0.05)))*solve( t(X)%*%X )
beta<-rep(0,p) # starting beta
S<-10000
BETA<-matrix(0,nrow=S,ncol=p)
ac<-0
# set.seed(1) # set seed
## rmvnorm function for proposals
rmvnorm<-function(n,mu,Sigma)
{ # samples from the multivariate normal distribution
E<-matrix(rnorm(n*length(mu)),n,length(mu))
t(  t(E%*%chol(Sigma)) +c(mu))
}
## MCMC
for(s in 1:S) {
#propose a new beta
beta.p<- t(rmvnorm(1, beta, var.prop))
lhr<- sum(dbern(y, exp(X%*%beta.p)/(1+exp(X%*%beta.p)) ,log=T)) -
sum(dbern(y, exp(X%*%beta)/(1+exp(X%*%beta)) ,log=T)) +
sum(dnorm(beta.p,pmn.beta,psd.beta,log=T)) -
sum(dnorm(beta,pmn.beta,psd.beta,log=T))
if( log(runif(1))< lhr ) { beta<-beta.p ; ac<-ac+1 }
BETA[s,]<-beta
}
# Plot the results:
print('Acceptance ratio:')
print(ac/S)
plot(BETA[,2],type="l",xlab="MCMC Iteration",ylab=expression(theta),main="Trace plot")
acf(BETA[,2])
print("Posterior means")
colMeans(BETA)
print("Effective sample size of both parameters")
ESS(BETA[,1])
ESS(BETA[,2])
n<-length(y) ; p<-dim(X)[2]
# priors and initialization
# can change these priors
pmn.beta<-c(-5,0.5)
psd.beta<-rep(20,p)
# can tweak the +-
var.prop<- var(logit(ifelse(y==1, y-0.05, y+0.05)))*solve( t(X)%*%X )
beta<-rep(0,p) # starting beta
S<-10000
BETA<-matrix(0,nrow=S,ncol=p)
ac<-0
# set.seed(1) # set seed
## rmvnorm function for proposals
rmvnorm<-function(n,mu,Sigma)
{ # samples from the multivariate normal distribution
E<-matrix(rnorm(n*length(mu)),n,length(mu))
t(  t(E%*%chol(Sigma)) +c(mu))
}
## MCMC
for(s in 1:S) {
#propose a new beta
beta.p<- t(rmvnorm(1, beta, var.prop))
lhr<- sum(dbern(y, exp(X%*%beta.p)/(1+exp(X%*%beta.p)) ,log=T)) -
sum(dbern(y, exp(X%*%beta)/(1+exp(X%*%beta)) ,log=T)) +
sum(dnorm(beta.p,pmn.beta,psd.beta,log=T)) -
sum(dnorm(beta,pmn.beta,psd.beta,log=T))
if( log(runif(1))< lhr ) { beta<-beta.p ; ac<-ac+1 }
BETA[s,]<-beta
}
# Plot the results:
print('Acceptance ratio:')
print(ac/S)
plot(BETA[,2],type="l",xlab="MCMC Iteration",ylab=expression(theta),main="Trace plot")
acf(BETA[,2])
print("Posterior means")
colMeans(BETA)
print("Effective sample size of both parameters")
ESS(BETA[,1])
ESS(BETA[,2])
n<-length(y) ; p<-dim(X)[2]
# priors and initialization
# can change these priors
pmn.beta<-c(-5,0.5)
psd.beta<-rep(20,p)
# can tweak the +-
var.prop<- var(logit(ifelse(y==1, y-0.05, y+0.05)))*solve( t(X)%*%X )
beta<-rep(0,p) # starting beta
S<-10000
BETA<-matrix(0,nrow=S,ncol=p)
ac<-0
# set.seed(1) # set seed
## rmvnorm function for proposals
rmvnorm<-function(n,mu,Sigma)
{ # samples from the multivariate normal distribution
E<-matrix(rnorm(n*length(mu)),n,length(mu))
t(  t(E%*%chol(Sigma)) +c(mu))
}
## MCMC
for(s in 1:S) {
#propose a new beta
beta.p<- t(rmvnorm(1, beta, var.prop))
lhr<- sum(dbern(y, exp(X%*%beta.p)/(1+exp(X%*%beta.p)) ,log=T)) -
sum(dbern(y, exp(X%*%beta)/(1+exp(X%*%beta)) ,log=T)) +
sum(dnorm(beta.p,pmn.beta,psd.beta,log=T)) -
sum(dnorm(beta,pmn.beta,psd.beta,log=T))
if( log(runif(1))< lhr ) { beta<-beta.p ; ac<-ac+1 }
BETA[s,]<-beta
}
# Plot the results:
print('Acceptance ratio:')
print(ac/S)
plot(BETA[,2],type="l",xlab="MCMC Iteration",ylab=expression(theta),main="Trace plot")
acf(BETA[,2])
print("Posterior means")
colMeans(BETA)
print("Effective sample size of both parameters")
ESS(BETA[,1])
ESS(BETA[,2])
n<-length(y) ; p<-dim(X)[2]
# priors and initialization
# can change these priors
pmn.beta<-c(-5,0.5)
psd.beta<-rep(20,p)
# can tweak the +-
var.prop<- var(logit(ifelse(y==1, y-0.05, y+0.05)))*solve( t(X)%*%X )
beta<-rep(0,p) # starting beta
S<-10000
BETA<-matrix(0,nrow=S,ncol=p)
ac<-0
# set.seed(1) # set seed
## rmvnorm function for proposals
rmvnorm<-function(n,mu,Sigma)
{ # samples from the multivariate normal distribution
E<-matrix(rnorm(n*length(mu)),n,length(mu))
t(  t(E%*%chol(Sigma)) +c(mu))
}
## MCMC
for(s in 1:S) {
#propose a new beta
beta.p<- t(rmvnorm(1, beta, var.prop))
lhr<- sum(dbern(y, exp(X%*%beta.p)/(1+exp(X%*%beta.p)) ,log=T)) -
sum(dbern(y, exp(X%*%beta)/(1+exp(X%*%beta)) ,log=T)) +
sum(dnorm(beta.p,pmn.beta,psd.beta,log=T)) -
sum(dnorm(beta,pmn.beta,psd.beta,log=T))
if( log(runif(1))< lhr ) { beta<-beta.p ; ac<-ac+1 }
BETA[s,]<-beta
}
# Plot the results:
print('Acceptance ratio:')
print(ac/S)
plot(BETA[,2],type="l",xlab="MCMC Iteration",ylab=expression(theta),main="Trace plot")
acf(BETA[,2])
print("Posterior means")
colMeans(BETA)
print("Effective sample size of both parameters")
ESS(BETA[,1])
ESS(BETA[,2])
hist(rnorm(5000, -10, 10))
hist(rnorm(5000, 0.8, 10))
hist(BETA[,1])
hist(BETA[,2])
hist(rnorm(5000, -5, 20))
hist(rnorm(5000, 0.5, 20))
hist(BETA[,1])
hist(BETA[,2])
hist(rnorm(10000, -5, 20))
hist(rnorm(10000, 0.5, 20))
hist(BETA[,1])
hist(BETA[,2])
n<-length(y) ; p<-dim(X)[2]
# priors and initialization
# can change these priors
pmn.beta<-c(-5,0.5)
psd.beta<-rep(15,p)
# can tweak the +-
var.prop<- var(logit(ifelse(y==1, y-0.05, y+0.05)))*solve( t(X)%*%X )
beta<-rep(0,p) # starting beta
S<-10000
BETA<-matrix(0,nrow=S,ncol=p)
ac<-0
# set.seed(1) # set seed
## rmvnorm function for proposals
rmvnorm<-function(n,mu,Sigma)
{ # samples from the multivariate normal distribution
E<-matrix(rnorm(n*length(mu)),n,length(mu))
t(  t(E%*%chol(Sigma)) +c(mu))
}
## MCMC
for(s in 1:S) {
#propose a new beta
beta.p<- t(rmvnorm(1, beta, var.prop))
lhr<- sum(dbern(y, exp(X%*%beta.p)/(1+exp(X%*%beta.p)) ,log=T)) -
sum(dbern(y, exp(X%*%beta)/(1+exp(X%*%beta)) ,log=T)) +
sum(dnorm(beta.p,pmn.beta,psd.beta,log=T)) -
sum(dnorm(beta,pmn.beta,psd.beta,log=T))
if( log(runif(1))< lhr ) { beta<-beta.p ; ac<-ac+1 }
BETA[s,]<-beta
}
# Plot the results:
print('Acceptance ratio:')
print(ac/S)
plot(BETA[,2],type="l",xlab="MCMC Iteration",ylab=expression(theta),main="Trace plot")
acf(BETA[,2])
print("Posterior means")
colMeans(BETA)
print("Effective sample size of both parameters")
ESS(BETA[,1])
ESS(BETA[,2])
hist(rnorm(10000, -5, 20))
hist(rnorm(10000, 0.5, 20))
hist(BETA[,1])
hist(BETA[,2])
n<-length(y) ; p<-dim(X)[2]
# priors and initialization
# can change these priors
pmn.beta<-c(-5,0.5)
psd.beta<-rep(15,p)
# can tweak the +-
var.prop<- var(logit(ifelse(y==1, y-0.05, y+0.05)))*solve( t(X)%*%X )
beta<-rep(0,p) # starting beta
S<-10000
BETA<-matrix(0,nrow=S,ncol=p)
ac<-0
set.seed(1) # set seed
## rmvnorm function for proposals
rmvnorm<-function(n,mu,Sigma)
{ # samples from the multivariate normal distribution
E<-matrix(rnorm(n*length(mu)),n,length(mu))
t(  t(E%*%chol(Sigma)) +c(mu))
}
## MCMC
for(s in 1:S) {
#propose a new beta
beta.p<- t(rmvnorm(1, beta, var.prop))
lhr<- sum(dbern(y, exp(X%*%beta.p)/(1+exp(X%*%beta.p)) ,log=T)) -
sum(dbern(y, exp(X%*%beta)/(1+exp(X%*%beta)) ,log=T)) +
sum(dnorm(beta.p,pmn.beta,psd.beta,log=T)) -
sum(dnorm(beta,pmn.beta,psd.beta,log=T))
if( log(runif(1))< lhr ) { beta<-beta.p ; ac<-ac+1 }
BETA[s,]<-beta
}
# Plot the results:
print('Acceptance ratio:')
print(ac/S)
plot(BETA[,2],type="l",xlab="MCMC Iteration",ylab=expression(theta),main="Trace plot")
acf(BETA[,2])
print("Posterior means")
colMeans(BETA)
print("Effective sample size of both parameters")
ESS(BETA[,1])
ESS(BETA[,2])
hist(rnorm(10000, -5, 15))
hist(rnorm(10000, 0.5, 15))
hist(BETA[,1])
hist(BETA[,2])
exp(c(0,0))
c(0,1) / c(1,1)
c(1,2) * c(2,3)
modBETA <- exp(BETA[,1] + BETA[,2] * X) / (1 + exp(BETA[,1] + BETA[,2] * X))
exp(BETA[,1] + BETA[,2] * X)
modBETA <- exp(BETA[,1] + BETA[,2] * X[,2]) / (1 + exp(BETA[,1] + BETA[,2] * X[,2]))
exp(BETA[,1] + BETA[,2] * X[,2])
modBETA <- exp(BETA[,1] + BETA[,2] * X[,2]) / (1 + exp(BETA[,1] + BETA[,2] * X[,2]))
(1 + exp(BETA[,1] + BETA[,2] * X[,2])
)
dim(BETA[,2] * X[,2])
dim(X[,2])
X
X[,2]
postbetas <- colMeans(BETA)
modBETA <- exp(postbetas[1] + postbetas[2] * X[,2]) / (1 + exp(postbetas[1] + postbetas[2] * X[,2]))
modBETA
exp(BETA[,1] + BETA[,2] * X[,2])
exp(BETA[,1] + BETA[,2] * X[1,2])
quantile(BETA[,1], c(0.025, 0.975))
quantile(BETA[,1], c(0.025, 0.975))[1]
quantile(BETA[,1], c(0.025, 0.975))[[1]]
postbetas <- colMeans(BETA)
modBETA <- exp(postbetas[1] + postbetas[2] * X[,2]) / (1 + exp(postbetas[1] + postbetas[2] * X[,2]))
# 2.5 band
c2.5s <- rep(NA, length(y))
c97.5s <- rep(NA, length(y))
for (i in 1:length(y)) {
distr <- exp(BETA[,1] + BETA[,2] * X[i,2]) / (1 + exp(BETA[,1] + BETA[,2] * X[i,2]))
q <- quantile(distr, c(0.025, 0.975))
c2.5s <- q[[1]]
c97.5s <- q[[2]]
}
# 97.5 band
?sort
sort(c(2,3,1))
length(c2.5s)
postbetas <- colMeans(BETA)
modBETA <- exp(postbetas[1] + postbetas[2] * X[,2]) / (1 + exp(postbetas[1] + postbetas[2] * X[,2]))
# 2.5 band
c2.5s <- rep(NA, length(y))
c97.5s <- rep(NA, length(y))
for (i in 1:length(y)) {
distr <- exp(BETA[,1] + BETA[,2] * X[i,2]) / (1 + exp(BETA[,1] + BETA[,2] * X[i,2]))
q <- quantile(distr, c(0.025, 0.975))
c2.5s[i] <- q[[1]]
c97.5s[i] <- q[[2]]
}
# 97.5 band
length(c2.5s)
summary(c2.5s)
summary(c97.5s)
dim(modBETA)
postbetas <- colMeans(BETA)
modBETA <- exp(postbetas[1] + postbetas[2] * X[,2]) / (1 + exp(postbetas[1] + postbetas[2] * X[,2]))
dim(modBETA)
modBETA
length(modBETA)
length(c2.5s)
plot(X[,2], modBETA)
# Compute expected value of func
postbetas <- colMeans(BETA)
predprobs <- exp(postbetas[1] + postbetas[2] * X[,2]) / (1 + exp(postbetas[1] + postbetas[2] * X[,2]))
# Compute bands using MCMC as posterior sample.
c2.5s <- rep(NA, length(y))
c97.5s <- rep(NA, length(y))
for (i in 1:length(y)) {
distr <- exp(BETA[,1] + BETA[,2] * X[i,2]) / (1 + exp(BETA[,1] + BETA[,2] * X[i,2]))
q <- quantile(distr, c(0.025, 0.975))
c2.5s[i] <- q[[1]]
c97.5s[i] <- q[[2]]
}
plot(X[,2], predprobs)
lines()
# Compute expected value of func
postbetas <- colMeans(BETA)
predprobs <- exp(postbetas[1] + postbetas[2] * X[,2]) / (1 + exp(postbetas[1] + postbetas[2] * X[,2]))
# Compute bands using MCMC as posterior sample.
c2.5s <- rep(NA, length(y))
c97.5s <- rep(NA, length(y))
for (i in 1:length(y)) {
distr <- exp(BETA[,1] + BETA[,2] * X[i,2]) / (1 + exp(BETA[,1] + BETA[,2] * X[i,2]))
q <- quantile(distr, c(0.025, 0.975))
c2.5s[i] <- q[[1]]
c97.5s[i] <- q[[2]]
}
plot(X[,2], predprobs)
# lines()
plot(X[,2], predprobs)
lines(X[,2], c2.5s)
lines(X[,2, c97.5s])
plot(X[,2], predprobs)
lines(X[,2], c2.5s)
lines(X[,2], c97.5s)
plot(X[,2], predprobs)
plot(X[,2], c2.5s)
plot(X[,2], c97.5s)
plot(X[,2], predprobs)
plot(X[,2], c2.5s, add=T)
plot(X[,2], c97.5s, add=T)
plot(X[,2], predprobs)
points(X[,2], c2.5s)
points(X[,2], c97.5s)
?points
plot(X[,2], predprobs)
curve(X[,2], c2.5s)
plot(X[,2], predprobs)
lines(c2.5s)
lines(c97.5s)
plot(X[,2], predprobs)
points(X[,2], c2.5s)
points(X[,2], c97.5s)
plot(X[,2], predprobs)
points(X[,2], c2.5s, color='r')
points(X[,2], c97.5s)
plot(X[,2], predprobs)
points(X[,2], c2.5s, col='r')
plot(X[,2], predprobs)
points(X[,2], c2.5s, col='red')
points(X[,2], c97.5s)
plot(X[,2], predprobs)
points(X[,2], c2.5s, col='red')
points(X[,2], c97.5s, col='green)
plot(X[,2], predprobs)
points(X[,2], c2.5s, col='red')
points(X[,2], c97.5s, col='green')
tinytex::install_tinytex()
library(tidyverse)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
setwd("~/Desktop/STAT425/project/predictingcovid")
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
setwd("~/Desktop/STAT425/project/predictingcovid")
MASK_USE_PATH <- "mask-use-by-county.csv"
MOBILITY_PATH <- "2020_US_Region_Mobility_Report.csv"
PROTEST_PATH <- "protests.csv"
mask_use <- read.csv(MASK_USE_PATH, colClasses = c("COUNTYFP" = "factor"))
mobility <- read.csv(MOBILITY_PATH,
colClasses = c(
"country_region_code" = "factor",
"country_region" = "factor",
"sub_region_1" = "factor",
"sub_region_2" = "factor",
"iso_3166_2_code" = "factor",
"census_fips_code" = "factor",
"date" = "Date"
)
)
mobility %<>%
group_by(census_fips_code) %>%
select(-c(
country_region_code,
country_region,
sub_region_1,
sub_region_2,
metro_area,
iso_3166_2_code,
date
)) %>%
summarise(across(.fns = ~ mean(na.omit(.x), na.rm = TRUE)))
mobility
mask_use
test = read_csv("07-21-2020.csv")
test
test <- read_csv(str_c(HOME, US_counties_COVID19_health_weather_data.csv))
HOME <- "/Users/jason/Desktop/STAT425/project/"
test <- read_csv(str_c(HOME, US_counties_COVID19_health_weather_data.csv))
test <- read_csv(str_c(HOME, "US_counties_COVID19_health_weather_data.csv"))
dim(test)
colnames(test)
test$date_stay_at_home_announced
test$date[1:5]
julytest = test %>% filter(date[7] == '7')
typeof(test$date[1])
test$date[1]
julytest = test %>% filter(date > dmy("01-07-2020") & date > dmy("31-07-2020"))
dmy("01-07-2020")
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lubridate)
setwd("~/Desktop/STAT425/project/predictingcovid")
dmy("01-07-2020")
julytest = test %>% filter(date > dmy("01-07-2020") & date > dmy("31-07-2020"))
dim(julytest)
dim(test)
range(julytest$date)
julytest = test %>% filter(date > dmy("01-07-2020") & date < dmy("31-07-2020"))
